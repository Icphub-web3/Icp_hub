/**
 * @fileoverview Storage Utility Module
 * 
 * Centralized storage management for ICPHub application.
 * Provides:
 * - Local storage operations with error handling
 * - Session storage operations
 * - Cache management with TTL
 * - Data serialization/deserialization
 * - Storage quota management
 * 
 * @author ICPHub Team
 * @version 1.0.0
 */

import { config } from '../config/index.js';\nimport { ICPHubError, ErrorTypes } from './errorHandler.js';\n\n/**\n * Storage Types\n */\nexport const StorageTypes = {\n  LOCAL: 'localStorage',\n  SESSION: 'sessionStorage',\n  MEMORY: 'memory',\n};\n\n/**\n * In-memory storage fallback for when localStorage/sessionStorage is unavailable\n */\nclass MemoryStorage {\n  constructor() {\n    this.data = new Map();\n  }\n\n  getItem(key) {\n    return this.data.get(key) || null;\n  }\n\n  setItem(key, value) {\n    this.data.set(key, value);\n  }\n\n  removeItem(key) {\n    this.data.delete(key);\n  }\n\n  clear() {\n    this.data.clear();\n  }\n\n  get length() {\n    return this.data.size;\n  }\n\n  key(index) {\n    const keys = Array.from(this.data.keys());\n    return keys[index] || null;\n  }\n}\n\n// Fallback storage instance\nconst memoryStorage = new MemoryStorage();\n\n/**\n * Check if storage is available\n * \n * @param {string} type - Storage type ('localStorage' or 'sessionStorage')\n * @returns {boolean} Whether storage is available\n */\nconst isStorageAvailable = (type) => {\n  try {\n    const storage = window[type];\n    const testKey = '__storage_test__';\n    storage.setItem(testKey, 'test');\n    storage.removeItem(testKey);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\n * Get storage instance with fallback\n * \n * @param {string} type - Storage type\n * @returns {Storage|MemoryStorage} Storage instance\n */\nconst getStorage = (type) => {\n  if (isStorageAvailable(type)) {\n    return window[type];\n  }\n  console.warn(`${type} is not available, falling back to memory storage`);\n  return memoryStorage;\n};\n\n/**\n * Storage class with enhanced functionality\n */\nclass ICPHubStorage {\n  constructor(storageType = StorageTypes.LOCAL, prefix = '') {\n    this.storageType = storageType;\n    this.prefix = prefix;\n    this.storage = storageType === StorageTypes.MEMORY \n      ? memoryStorage \n      : getStorage(storageType);\n  }\n\n  /**\n   * Generate prefixed key\n   * \n   * @param {string} key - Original key\n   * @returns {string} Prefixed key\n   */\n  _getPrefixedKey(key) {\n    return this.prefix ? `${this.prefix}${key}` : key;\n  }\n\n  /**\n   * Serialize data for storage\n   * \n   * @param {any} data - Data to serialize\n   * @returns {string} Serialized data\n   */\n  _serialize(data) {\n    try {\n      return JSON.stringify({\n        data,\n        timestamp: Date.now(),\n        version: config.app.version,\n      });\n    } catch (error) {\n      throw new ICPHubError(\n        'Failed to serialize data for storage',\n        ErrorTypes.CLIENT,\n        'MEDIUM',\n        { originalError: error }\n      );\n    }\n  }\n\n  /**\n   * Deserialize data from storage\n   * \n   * @param {string} serializedData - Serialized data\n   * @returns {any} Deserialized data\n   */\n  _deserialize(serializedData) {\n    try {\n      const parsed = JSON.parse(serializedData);\n      return parsed.data;\n    } catch (error) {\n      throw new ICPHubError(\n        'Failed to deserialize data from storage',\n        ErrorTypes.CLIENT,\n        'MEDIUM',\n        { originalError: error, data: serializedData }\n      );\n    }\n  }\n\n  /**\n   * Check if stored data has expired\n   * \n   * @param {string} serializedData - Serialized data\n   * @param {number} ttl - Time to live in milliseconds\n   * @returns {boolean} Whether data has expired\n   */\n  _isExpired(serializedData, ttl) {\n    if (!ttl) return false;\n    \n    try {\n      const parsed = JSON.parse(serializedData);\n      return Date.now() - parsed.timestamp > ttl;\n    } catch (error) {\n      return true; // Treat invalid data as expired\n    }\n  }\n\n  /**\n   * Set item in storage\n   * \n   * @param {string} key - Storage key\n   * @param {any} value - Value to store\n   * @param {number} ttl - Time to live in milliseconds (optional)\n   * @returns {boolean} Success status\n   */\n  setItem(key, value, ttl = null) {\n    try {\n      const prefixedKey = this._getPrefixedKey(key);\n      const serializedData = this._serialize(value);\n      \n      // Add TTL information if provided\n      if (ttl) {\n        const dataWithTTL = {\n          ...JSON.parse(serializedData),\n          ttl,\n          expiresAt: Date.now() + ttl,\n        };\n        this.storage.setItem(prefixedKey, JSON.stringify(dataWithTTL));\n      } else {\n        this.storage.setItem(prefixedKey, serializedData);\n      }\n      \n      return true;\n    } catch (error) {\n      if (error.name === 'QuotaExceededError') {\n        throw new ICPHubError(\n          'Storage quota exceeded',\n          ErrorTypes.CLIENT,\n          'HIGH',\n          { key, storageType: this.storageType }\n        );\n      }\n      throw new ICPHubError(\n        'Failed to store data',\n        ErrorTypes.CLIENT,\n        'MEDIUM',\n        { key, originalError: error }\n      );\n    }\n  }\n\n  /**\n   * Get item from storage\n   * \n   * @param {string} key - Storage key\n   * @param {any} defaultValue - Default value if key doesn't exist\n   * @returns {any} Stored value or default value\n   */\n  getItem(key, defaultValue = null) {\n    try {\n      const prefixedKey = this._getPrefixedKey(key);\n      const serializedData = this.storage.getItem(prefixedKey);\n      \n      if (!serializedData) {\n        return defaultValue;\n      }\n\n      // Check for TTL expiration\n      const parsed = JSON.parse(serializedData);\n      if (parsed.ttl && this._isExpired(serializedData, parsed.ttl)) {\n        this.removeItem(key);\n        return defaultValue;\n      }\n\n      return this._deserialize(serializedData);\n    } catch (error) {\n      console.warn(`Failed to retrieve item '${key}' from storage:`, error);\n      return defaultValue;\n    }\n  }\n\n  /**\n   * Remove item from storage\n   * \n   * @param {string} key - Storage key\n   * @returns {boolean} Success status\n   */\n  removeItem(key) {\n    try {\n      const prefixedKey = this._getPrefixedKey(key);\n      this.storage.removeItem(prefixedKey);\n      return true;\n    } catch (error) {\n      console.warn(`Failed to remove item '${key}' from storage:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all items with the current prefix\n   * \n   * @returns {boolean} Success status\n   */\n  clear() {\n    try {\n      if (this.prefix) {\n        // Clear only items with our prefix\n        const keysToRemove = [];\n        for (let i = 0; i < this.storage.length; i++) {\n          const key = this.storage.key(i);\n          if (key && key.startsWith(this.prefix)) {\n            keysToRemove.push(key);\n          }\n        }\n        keysToRemove.forEach(key => this.storage.removeItem(key));\n      } else {\n        this.storage.clear();\n      }\n      return true;\n    } catch (error) {\n      console.warn('Failed to clear storage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys with the current prefix\n   * \n   * @returns {string[]} Array of keys\n   */\n  getAllKeys() {\n    const keys = [];\n    try {\n      for (let i = 0; i < this.storage.length; i++) {\n        const key = this.storage.key(i);\n        if (key && (!this.prefix || key.startsWith(this.prefix))) {\n          keys.push(this.prefix ? key.substring(this.prefix.length) : key);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to get storage keys:', error);\n    }\n    return keys;\n  }\n\n  /**\n   * Get storage size information\n   * \n   * @returns {object} Storage size information\n   */\n  getStorageInfo() {\n    try {\n      let totalSize = 0;\n      let itemCount = 0;\n      \n      for (let i = 0; i < this.storage.length; i++) {\n        const key = this.storage.key(i);\n        if (key && (!this.prefix || key.startsWith(this.prefix))) {\n          const value = this.storage.getItem(key);\n          totalSize += (key.length + (value ? value.length : 0)) * 2; // UTF-16\n          itemCount++;\n        }\n      }\n\n      return {\n        itemCount,\n        totalSize,\n        totalSizeKB: Math.round(totalSize / 1024 * 100) / 100,\n        storageType: this.storageType,\n      };\n    } catch (error) {\n      return {\n        itemCount: 0,\n        totalSize: 0,\n        totalSizeKB: 0,\n        storageType: this.storageType,\n        error: error.message,\n      };\n    }\n  }\n\n  /**\n   * Clean up expired items\n   * \n   * @returns {number} Number of items removed\n   */\n  cleanupExpired() {\n    let removedCount = 0;\n    const keys = this.getAllKeys();\n    \n    keys.forEach(key => {\n      try {\n        const prefixedKey = this._getPrefixedKey(key);\n        const serializedData = this.storage.getItem(prefixedKey);\n        \n        if (serializedData) {\n          const parsed = JSON.parse(serializedData);\n          if (parsed.ttl && this._isExpired(serializedData, parsed.ttl)) {\n            this.removeItem(key);\n            removedCount++;\n          }\n        }\n      } catch (error) {\n        // Remove invalid data\n        this.removeItem(key);\n        removedCount++;\n      }\n    });\n    \n    return removedCount;\n  }\n}\n\n// Create storage instances\nexport const localStorage = new ICPHubStorage(\n  StorageTypes.LOCAL,\n  config.storage.localStoragePrefix\n);\n\nexport const sessionStorage = new ICPHubStorage(\n  StorageTypes.SESSION,\n  config.storage.sessionStoragePrefix\n);\n\nexport const memoryStorageInstance = new ICPHubStorage(StorageTypes.MEMORY);\n\n/**\n * Cache class with TTL support\n */\nexport class Cache {\n  constructor(storage = localStorage, defaultTTL = config.storage.cacheTimeout) {\n    this.storage = storage;\n    this.defaultTTL = defaultTTL;\n  }\n\n  /**\n   * Set cache item with TTL\n   * \n   * @param {string} key - Cache key\n   * @param {any} value - Value to cache\n   * @param {number} ttl - Time to live (optional, uses default if not provided)\n   */\n  set(key, value, ttl = this.defaultTTL) {\n    return this.storage.setItem(`cache_${key}`, value, ttl);\n  }\n\n  /**\n   * Get cache item\n   * \n   * @param {string} key - Cache key\n   * @param {any} defaultValue - Default value if not found or expired\n   * @returns {any} Cached value or default\n   */\n  get(key, defaultValue = null) {\n    return this.storage.getItem(`cache_${key}`, defaultValue);\n  }\n\n  /**\n   * Remove cache item\n   * \n   * @param {string} key - Cache key\n   */\n  remove(key) {\n    return this.storage.removeItem(`cache_${key}`);\n  }\n\n  /**\n   * Clear all cache items\n   */\n  clear() {\n    const keys = this.storage.getAllKeys();\n    keys.filter(key => key.startsWith('cache_')).forEach(key => {\n      this.storage.removeItem(key);\n    });\n  }\n\n  /**\n   * Clean up expired cache items\n   */\n  cleanup() {\n    return this.storage.cleanupExpired();\n  }\n}\n\n// Default cache instance\nexport const cache = new Cache();\n\n/**\n * Utility functions\n */\nexport const StorageUtils = {\n  /**\n   * Check if storage is available\n   */\n  isAvailable: isStorageAvailable,\n\n  /**\n   * Get storage quota information (experimental)\n   */\n  async getQuotaInfo() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      try {\n        const estimate = await navigator.storage.estimate();\n        return {\n          quota: estimate.quota,\n          usage: estimate.usage,\n          available: estimate.quota - estimate.usage,\n          percentage: Math.round((estimate.usage / estimate.quota) * 100),\n        };\n      } catch (error) {\n        console.warn('Failed to get storage quota info:', error);\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Migrate data between storage types\n   */\n  migrate(fromStorage, toStorage, keys = null) {\n    const keysToMigrate = keys || fromStorage.getAllKeys();\n    let migratedCount = 0;\n    \n    keysToMigrate.forEach(key => {\n      try {\n        const value = fromStorage.getItem(key);\n        if (value !== null) {\n          toStorage.setItem(key, value);\n          migratedCount++;\n        }\n      } catch (error) {\n        console.warn(`Failed to migrate key '${key}':`, error);\n      }\n    });\n    \n    return migratedCount;\n  },\n};\n\nexport default {\n  ICPHubStorage,\n  StorageTypes,\n  localStorage,\n  sessionStorage,\n  memoryStorageInstance,\n  Cache,\n  cache,\n  StorageUtils,\n};
